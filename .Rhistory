Q4 = function(n){
x = 0
y = 0
v = c(NULL)
z = c(NULL)
v[1] = 0
z[1] = 0
for(i in 2:n){                       # comeÃ§a com 2. pois o primeiro momento jÃ¡ esta em (0,0)
m = runif(1)
if(m<0.5){                       # se m < 0.5, se move na horizontal
m=runif(1)
if(m<0.5){x=x+1}else{x=x-1}   # se m < 0.5, se move para direita, senÃ£o, para a esquerda
v[i] = x
if(i == 1){z[i] = 0}else      # a coordenada vertical se mantÃ©m
{z[i] = z[i-1]}
}else{                        # se m > 0.5, se move na vertical
m=runif(1)
if(m<0.5){y=y+1}else{y=y-1}   # se m < 0.5, se move para cima, senÃ£o, para baixo
z[i] = y
if(i == 1){v[i] = 0}else      # a coordenada horizontal se mantÃ©m
{v[i] = v[i-1]}
}}
plot(v,z, type = "l")                # plotando o grÃ¡fico em linhas
}
Q4(1000)
Q4(1000)
Q4(1000)
Q4(1000)
Q4(1000)
Q4(1000)
Q4(1000)
Q4(1000)
Q4 = function(n){
x = 0
y = 0
v = c(NULL)
z = c(NULL)
v[1] = 0
z[1] = 0
for(i in 2:n){                       # comeÃ§a com 2. pois o primeiro momento jÃ¡ esta em (0,0)
m = runif(1)
if(m<0.5){                       # se m < 0.5, se move na horizontal
m=runif(1)
if(m<0.5){x=x+1}else{x=x-1}   # se m < 0.5, se move para direita, senÃ£o, para a esquerda
v[i] = x
if(i == 1){z[i] = 0}else      # a coordenada vertical se mantÃ©m
{z[i] = z[i-1]}
}else{                        # se m > 0.5, se move na vertical
m=runif(1)
if(m<0.5){y=y+1}else{y=y-1}   # se m < 0.5, se move para cima, senÃ£o, para baixo
z[i] = y
if(i == 1){v[i] = 0}else      # a coordenada horizontal se mantÃ©m
{v[i] = v[i-1]}
}}
plot(v,z, type = "l")                # plotando o grÃ¡fico em linhas
}
Q4(1000)
Q4(10000)
Q4(10000)
Q4(5000)
Q4(5000)
Q4(500)
Q4(500)
Q4(1000)
Q4(1000)
Q4(1000)
# Q1
runif(1)
q1 = function(n){
Sn = 0                                        # objeto a ser usado na contagem
a = c(NULL)                                   # vetor a ser usado para guardar
for(i in 1:n){                                #  os diferentes valores de Sn
m = runif(1)
if(m<0.5){Sn = Sn + 1                     # se menor que 0.5, soma 1
}else{
Sn = Sn - 1}                              # senão, subtrai 1
a[i] = Sn}                                # guardando os valores de Sn
cat(plot(a), Sn)                              # devolvendo Sn e o gráfico
}
q1(100)
# Q2
q2 = function(n,r){
Sn = 0                           # objeto de contagem
a = c(NULL)                      # vetor a ser usado para guardar os diferentes valores de sn
for(j in 1:r){                   # rodando  os r passeios aleatórios
for(i in 1:n){               # rodando cada passeio aleatório
m = runif(1)
if(m<0.5){Sn = Sn + 1    # se menor que 0.5, soma 1
}else{
Sn = Sn - 1}}            # senão, subtrai 1
a[j] = Sn                    # guardando os valores de Sn
Sn = 0}                      # retornando Sn a 0 para contar o próximo passeio
cat(mean(a))                 # retornando a média dos Sn
return(hist(a))              # retornando o histograma dos sn
}
q2(100,10)
# Q3
# A
q3a = function(n,r){
if((r+n)%%2 != 0){stop("N e R devem ter a mesma paridade")}
if(r>n){stop("R deve ser igual ou menor que N ")}
resp = factorial(n)/((factorial((n+r)/2)*factorial(n - (n+r)/2))) # fórmula do numero de
return(resp)                                                      # caminhos da origem até
}                                                                       # (n,r)
q3a(10,10)
q3a(4,0)
# B
q3b = function(n,r){
if((r+n)%%2 != 0){stop("N e R devem ter a mesma paridade")}
if(r>n){stop("R deve ser igual ou menor que N ")}
cam = factorial(n)/((factorial((n+r)/2)*factorial(n - (n+r)/2))) # fórmula do numero de caminhos da origem até (n,r)
resp = cam/(2^n)                                                 # dividindo pelo número de caminhos possíveis/
return(resp)                      # retornando a probbilidade
}
q3b(100,10)
# Q4
q4 = function(n,r){
Sn = 0                                       # objeto que ajudará na contagem
prop = c(NULL)                               # vetor que guardará os valores da proporção                                # vetor que guardará os valores de Sn
for(j in 1:n){                               # rodando os n passeios
for(i in 1:r){                             # rodando cada passeio
m = runif(1)
if(m<0.5){Sn = Sn + 1                    # se menor que 0.5, soma 1
}else{                                   # senão
Sn = Sn - 1}}                            # subtrai 1
if(Sn == 10){prop[j] = 1                   # contando os Sn = 10;
}else{
prop[j] = 0}
Sn = 0}
cat(" Proporção de passeios onde (Sn = 10):",mean(prop))  # retorno da probabilidade
}
q4(1000,100)
# Q5
# A
q5a = function(n){
if(n%%2 != 0){stop("N deve ser um número par")}             # verificando se n é par
U1 = factorial(2*n)/((factorial(n)*factorial(2*n - n)))     # primeira parte da f´´ormula de Un
U2 = 2^(2*n)                                                # segunda parte da fórmua de Un
U  = U1/U2                                                  # divisão
cat(U)                                                      # resultado
}
q5a(10)
q5a(2)
# B
q5b = function(n,alt){
if(n%%2 != 0){stop("N deve ser um nÃºmero par")}       # verificando se n é ímpar
if(alt == "Stirling"){                                 # se o usuário prefere Stirling
resp = 1/sqrt(pi*n)                                 # fórmula
return(resp)                                        # retornando a resposta
}
U1 = factorial(2*n)/(factorial(n)^2)                   # mesmo código dado anteriormente
U2 = 2^(2*n)
U  = U1/U2
cat(U)
}
q5b(2,"Stirling")
# C
a = data.frame(NULL)
# Q6
q6 = function(n,r){
Sn = 0                            # mesmo código do exercício 4, porém com Sn = 0;
prop = c(NULL)
for(j in 1:r){
for(i in 1:n){
m = runif(1)
if(m<0.5){Sn = Sn + 1}else{Sn = Sn - 1}}
if(Sn == 0){prop[j] = 1}else{prop[j] = 0}
Sn = 0}
cat("Proporção de passeios onde (Sn = 0):",mean(prop))
}
q6(1000,100)
# Q7
q7 = function(n){
if(n%%2 != 0){stop("N deve ser um número par")}       # Verificando se n é par
if( n <= 0 ){stop("N deve ser maior que 0")}          # Verificando se n é positivo
U1 = factorial(2*n)/(factorial(n)^2)
U2 = 2^(2*n)
U  = U1/U2                                            # fórmula de Un já vista antes
resp = U/(2*n -1)                                     # fórmula de fn = Un/(2*n-1)
cat(resp)                                             # retornando resposta
}
q7(0)
q7(4)
# Q8
q8 = function(n,k){
if(n%%2 != 0){stop("N deve ser um número par")}    # Verificando se n e k são números pares.
if(k%%2 != 0){stop("K deve ser um número par")}
U = factorial(n - k)/((factorial(n - k)*factorial(n - k)))/2^(2*(n-k))  # fórmula de Un
K = factorial(k)/((factorial(k)*factorial(k)))/2^(2*(k))                # fórmula de Un com k
cat(U*K)                                                 # retornando a resposta: U(n)*U(n-k)
}
q8(20,10)
# Q9
q9 = function(n,r){
a = c(NULL)
for(j in 1:n){
Sn = 0
for(i in 1:r){
m = runif(1)
if(m<0.5){Sn = Sn + 1}else{Sn = Sn - 1}
if(Sn == 0){a[i] = i}}}
cat(a)
plot(a)
}
q9(1000,100)
# Q9
q9 = function(n,r){
a = c(NULL)
for(j in 1:n){
Sn = 0
for(i in 1:r){
m = runif(1)
if(m<0.5){Sn = Sn + 1}else{Sn = Sn - 1}
if(Sn == 0){a[i] = i}}}
cat(a)
plot(a)
}
q9(1000,100)
# Q9
q9 = function(n,r){
a = c(NULL)
for(j in 1:n){
Sn = 0
for(i in 1:r){
m = runif(1)
if(m<0.5){Sn = Sn + 1}else{Sn = Sn - 1}
if(Sn == 0){a[i] = i}}}
cat(a)
plot(Sn)
}
q9(1000,100)
# Q9
q9 = function(n,r){
a = c(NULL)
for(j in 1:n){
Sn = 0
for(i in 1:r){
m = runif(1)
if(m<0.5){Sn = Sn + 1}else{Sn = Sn - 1}
if(Sn == 0){a[i] = i}}}
cat(a)
plot(a)
}
q9(1000,100)
q9(1000,5)
# Q1 - r mudanÃ§as de sinal em 2n+1 unidades de tempo;
q1 = function(n,r){
resp = choose(2*n+1 , n+r+1)/(2^(2*n))
cat(resp)
}
q1(2,2)
# Q2 - prob do ponto mÃ¡x de um PA de tamanho n ser r
q2 = function(n,r){
if(n < r){stop("n deve ser maior ou igual a r")}
if((n+r)%%2 == 0){
resp = choose(n, (n+r)/2)/(2^n)
}else{
resp = choose(n, (n+r+1)/2)/(2^n)
}
cat(resp)
}
q2(9,6)
q3 = function(n,r){
f  = c(NULL)
c  = c(NULL)
b  = c(NULL)
for(i in 1:r){     # rodando os 1000 passeios
a  = 0         # zerando para a contagem do pr?ximo Passeio
d  = 0         # zerando para a contagem do pr?ximo Passeio
v  = c(NULL)
Sn = 0
for(j in 1:n){    # rodando Passeio de 199 passos
m = runif(1)          # criando o passeio
if(m < 0.5){Sn = Sn + 1}else{Sn = Sn - 1}
v[j] = Sn
if(j > 2){                                                           # um Passeio s? pode mudar de sinal depois do 2 momento;
if(v[j - 2] > 0 & v[j] < 0 || v[j - 2] < 0 & v[j] > 0){a = a + 1} # contando o n?mero de troca de sinal de cada passeio;
}
if(Sn > 0){d = d + 1}     # contando o n?mero de lados acima do eixo x de cada passeio
}
f[i] = a                 # armazenando o n?mero de troca de sinal de cada passeio
b[i] = max(v)            # armazenando o maior valor de cada passeio
c[i] = d                 # armazenando o n?mero de lados acima do eixo x
}
cat("\nN?mero de troca de sinais de cada Passeio:",f)
cat("\n")
cat("\nO maior valor de cada Passeio:",b)
cat("\n")
cat("\nO n?mero de lados de acima do eixo x de cada passeio:",c)
plot(v)
}
q3(199,3)
# A
q3a = function(n,r){
f  = c(NULL)
c  = c(NULL)
b  = c(NULL)
for(i in 1:r){    # rodando os 1000 passeios
a = 0           # zerando para a contagem do pr?ximo Passeio
d = 0           # zerando para a contagem do pr?ximo Passeio
v = c(NULL)     # limpando o vetor v para armazenar o pr?ximo Passeio
Sn = 0          # zerando para a contagem do Sn do pr?ximo Passeio
for(j in 1:n){          # rodando Passeio de 199 passos
m = runif(1)          # criando o passeio
if(m < 0.5){Sn = Sn + 1}else{Sn = Sn - 1}
v[j] = Sn
if(j > 2){                                                           # um Passeio s? pode mudar de sinal depois do 2 momento;
if(v[j - 2] > 0 & v[j] < 0 || v[j - 2] < 0 & v[j] > 0){a = a + 1}  # contando o n?mero de troca de sinal de cada passeio;
}
if(Sn > 0){d = d + 1}     # contando o n?mero de lados acima do eixo x de cada passeio
}
f[i] = a                    # armazenando o n?mero de troca de sinal de cada passeio
b[i] = max(v)               # armazenando o maior valor de cada passeio
c[i] = d                    # armazenando o n?mero de lados acima do eixo x
}
cat("\nN?mero de troca de sinais de cada Passeio:",f)
cat("\n")
cat("\nO maior valor de cada Passeio:",b)
cat("\n")
cat("\nO n?mero de lados de acima do eixo x de cada passeio:",c)
hist(f)
}
q3a(199,10000)
v1 = c(q1(199,1),q1(199,2),q1(199,3),q1(199,4),q1(199,5),
q1(199,10),q1(199,20),q1(199,30),q1(199,40))
v2 =
table(v1,v2)
# C
q3c = function(n,r){
f  = c(NULL)
c  = c(NULL)
b  = c(NULL)
for(i in 1:r){    # rodando os 1000 passeios
a = 0           # zerando para a contagem do pr?ximo Passeio
d = 0           # zerando para a contagem do pr?ximo Passeio
v = c(NULL)     # limpando o vetor v para armazenar o pr?ximo Passeio
Sn = 0          # zerando para a contagem do Sn do pr?ximo Passeio
for(j in 1:n){          # rodando Passeio de 199 passos
m = runif(1)          # criando o passeio
if(m < 0.5){Sn = Sn + 1}else{Sn = Sn - 1}
v[j] = Sn
if(j > 2){                                                           # um Passeio s? pode mudar de sinal depois do 2 momento;
if(v[j - 2] > 0 & v[j] < 0 || v[j - 2] < 0 & v[j] > 0){a = a + 1}  # contando o n?mero de troca de sinal de cada passeio;
}
if(Sn > 0){d = d + 1}     # contando o n?mero de lados acima do eixo x de cada passeio
}
f[i] = a                    # armazenando o n?mero de troca de sinal de cada passeio
b[i] = max(v)               # armazenando o maior valor de cada passeio
c[i] = d                    # armazenando o n?mero de lados acima do eixo x
}
cat("\nN?mero de troca de sinais de cada Passeio:",f)
cat("\n")
cat("\nO maior valor de cada Passeio:",b)
cat("\n")
cat("\nO n?mero de lados de acima do eixo x de cada passeio:",c)
hist(b)
}
q3c(199,1000)
# D
w1 = c(q2(199,1),q2(199,2),q2(199,3),q2(199,4),q2(199,5),
q2(199,10),q2(199,15),q2(199,20),q2(199,50),q2(199,100))
w2 = c()
# E
q3e = function(n,r){
f  = c(NULL)
c  = c(NULL)
b  = c(NULL)
for(i in 1:r){    # rodando os 1000 passeios
a = 0           # zerando para a contagem do pr?ximo Passeio
d = 0           # zerando para a contagem do pr?ximo Passeio
v = c(NULL)     # limpando o vetor v para armazenar o pr?ximo Passeio
Sn = 0          # zerando para a contagem do Sn do pr?ximo Passeio
for(j in 1:n){          # rodando Passeio de 199 passos
m = runif(1)          # criando o passeio
if(m < 0.5){Sn = Sn + 1}else{Sn = Sn - 1}
v[j] = Sn
if(j > 2){                                                           # um Passeio s? pode mudar de sinal depois do 2 momento;
if(v[j - 2] > 0 & v[j] < 0 || v[j - 2] < 0 & v[j] > 0){a = a + 1}  # contando o n?mero de troca de sinal de cada passeio;
}
if(Sn > 0){d = d + 1}     # contando o n?mero de lados acima do eixo x de cada passeio
}
f[i] = a                    # armazenando o n?mero de troca de sinal de cada passeio
b[i] = max(v)               # armazenando o maior valor de cada passeio
c[i] = d                    # armazenando o n?mero de lados acima do eixo x
}
cat("\nN?mero de troca de sinais de cada Passeio:",f)
cat("\n")
cat("\nO maior valor de cada Passeio:",b)
cat("\n")
cat("\nO n?mero de lados de acima do eixo x de cada passeio:",c)
hist(c)
}
q3e(199,1000)
Q4 = function(n){
x = 0
y = 0
v = c(NULL)
z = c(NULL)
v[1] = 0
z[1] = 0
for(i in 2:n){                       # comeÃ§a com 2. pois o primeiro momento jÃ¡ esta em (0,0)
m = runif(1)
if(m<0.5){                       # se m < 0.5, se move na horizontal
m=runif(1)
if(m<0.5){x=x+1}else{x=x-1}   # se m < 0.5, se move para direita, senÃ£o, para a esquerda
v[i] = x
if(i == 1){z[i] = 0}else      # a coordenada vertical se mantÃ©m
{z[i] = z[i-1]}
}else{                        # se m > 0.5, se move na vertical
m=runif(1)
if(m<0.5){y=y+1}else{y=y-1}   # se m < 0.5, se move para cima, senÃ£o, para baixo
z[i] = y
if(i == 1){v[i] = 0}else      # a coordenada horizontal se mantÃ©m
{v[i] = v[i-1]}
}}
plot(v,z, type = "l")                # plotando o grÃ¡fico em linhas
}
Q4(1000)
Q4(1000)
Q4(1000)
# 5 - fun??o que contr?i n replica??es de um P.A. de n passos em Z2;
#     retorna um hisograma com a dist?ncia de Sn a origem
Q5 = function(n,r){
x  = 0
y  = 0
v  = c(NULL)
z  = c(NULL)
Sn = c(NULL)
v[1]  = 0                      # similar ao passeio anterior
z[1]  = 0
for(j in 1:r){
for(i in 2:n){
m = runif(1)
if(m<0.5){
m=runif(1)
if(m<0.5){x=x+1}else{x=x-1}
v[i] = x
if(i == 1){z[i] = 0}else
{z[i] = z[i-1]}
}else{
m=runif(1)
if(m<0.5){y=y+1}else{y=y-1}
z[i] = y
if(i == 1){v[i] = 0}else
{v[i] = v[i-1]}
}}
Sn[j] = sqrt((v[n])^2) + sqrt((z[n])^2)
}
hist(Sn)
}
Q5(1000,100)
q6 = function(r,n){
m = c(NULL)     # vetor que conter? os valores de runif;
s = c(NULL)     # vetor que conter? o maior valor de cada instervalo;
c = c(NULL)
for (i in 1:r){
s[i] = i/r
}
for(j in 1:n){
f = rep(0,r)     # vetor que conter? os intervalos ao qual cada runif pertence;
for(i in 1:r){
m[i] = runif(1)
if(m[i]<0.5){f[i] = f[i] + 1}
if(f[i] == 2)break}
c[j] = sum(f)
}                      # obs: os intervalos s?o como os amigos e runif s?o como as visitas;
hist(c)
cat("\nVetor com o maior valor de cada intervalo:",s)
#     cat("\nVetor com os vizinhos que foram visitados:",f)
}
q6(3,1000)
q6(5,1000)
q6(10,1000)
q6(20,1000)
q6(100,1000)
q7 = function(r,n){
m = c(NULL)     # vetor que conter? os valores de runif;
s = c(NULL)     # vetor que conter? o maior valor de cada instervalo;
c = c(NULL)
for (i in 1:r){
s[i] = i/r
}
for(j in 1:n){
f = rep(0,r)     # vetor que conter? os intervalos ao qual cada runif pertence;
d = 1
repeat{
m[d] = runif(1)
if(m[d] < .5){f[d] = f[d] + 1}
if(f[d] == 2){f[d] = 1}
d = d + 1
if(sum(f) == r){break}}
c[j] = sum(f)
}                      # obs: os intervalos s?o como os amigos e runif s?o como as visitas;
hist(c)
cat("\nVetor com o maior valor de cada intervalo:",s)
#     cat("\nVetor com os vizinhos que foram visitados:",f)
}
q7(3,1000)
q7(5,1000)
q7(10,1000)
q7(20,1000)
